{
    "docs": [
        {
            "location": "/",
            "text": "Utilities for the game of Go\n\n\n\n\n\n\nData structures and utilities to represent the \ngame of Go\n.\n\n\nThis library depends on \nImmutable.js\n and \nlodash\n.\n\n\nGetting Started\n\n\nInstall \ngodash\n via \nnpm\n.\n\n\nnpm install godash\n\n\n\n\n\nrequire\n and use it in your modules.\n\n\nvar\n \ngodash\n \n=\n \nrequire\n(\n'godash'\n);\n\n\nvar\n \nboard\n \n=\n \nnew\n \ngodash\n.\nBoard\n(\n19\n);\n\n\nvar\n \ntengen\n \n=\n \nnew\n \ngodash\n.\nCoordinate\n(\n9\n,\n \n9\n);\n \n// 0-based\n\n\n\nboard\n.\nmoves\n.\nhas\n(\ntengen\n);\n \n// false\n\n\n\nvar\n \nstandardOpening\n \n=\n \nplaceStone\n(\n\n    \nboard\n,\n\n    \ntengen\n,\n\n    \ngodash\n.\nBLACK\n\n\n);\n\n\nstandardOpening\n.\nmoves\n.\nhas\n(\ntengen\n);\n \n// true\n\n\n\n\n\n\nWhy Godash?\n\n\nGodash provides the \"primitives\" for Go manipulations necessary for creating\nUIs that go beyond a simple SGF player.  You can mix and match the functions\nprovided to create whatever wacky UI you want without having to reinvent the\nwheel every time.\n\n\nGodash also strives to keep a clean and simple API so that new functionality\ncan be easily extended.\n\n\nCheck out the \ndocumentation\n to see what Godash provides.\n\n\nRoadmap\n\n\nGodash doesn't currently do very much parameter checking.  It'd probably be\nnice to add that.\n\n\nThere also isn't much support for writing SGFs.  This, too, might be added in\nthe future.  Further, reading SGFs is a bit brittle at the moment since the\nfull SGF spec is not implemented.",
            "title": "Home"
        },
        {
            "location": "/#utilities-for-the-game-of-go",
            "text": "Data structures and utilities to represent the  game of Go .  This library depends on  Immutable.js  and  lodash .",
            "title": "Utilities for the game of Go"
        },
        {
            "location": "/#getting-started",
            "text": "Install  godash  via  npm .  npm install godash  require  and use it in your modules.  var   godash   =   require ( 'godash' );  var   board   =   new   godash . Board ( 19 );  var   tengen   =   new   godash . Coordinate ( 9 ,   9 );   // 0-based  board . moves . has ( tengen );   // false  var   standardOpening   =   placeStone ( \n     board , \n     tengen , \n     godash . BLACK  );  standardOpening . moves . has ( tengen );   // true",
            "title": "Getting Started"
        },
        {
            "location": "/#why-godash",
            "text": "Godash provides the \"primitives\" for Go manipulations necessary for creating\nUIs that go beyond a simple SGF player.  You can mix and match the functions\nprovided to create whatever wacky UI you want without having to reinvent the\nwheel every time.  Godash also strives to keep a clean and simple API so that new functionality\ncan be easily extended.  Check out the  documentation  to see what Godash provides.",
            "title": "Why Godash?"
        },
        {
            "location": "/#roadmap",
            "text": "Godash doesn't currently do very much parameter checking.  It'd probably be\nnice to add that.  There also isn't much support for writing SGFs.  This, too, might be added in\nthe future.  Further, reading SGFs is a bit brittle at the moment since the\nfull SGF spec is not implemented.",
            "title": "Roadmap"
        },
        {
            "location": "/documentation/",
            "text": "Board\n\n\nUtilities surrounding the board centering around an immutable \nBoard\n\nobject.\n\n\nCoordinate\n\n\n\n\nnew\n \ngodash\n.\nCoordinate\n(\nx\n,\n \ny\n)\n\n\n\n\n\n\nClass representing a single location on a Go board.  Inherits from\n\nImmutable.Record\n.\n\n\nArguments\n\n\n\n\nx\n \n(number)\n: Location on one axis.\n\n\ny\n \n(number)\n: Location on the other axis.\n\n\n\n\nProperties\n\n\n\n\nx\n \n(number)\n: Location on one axis.\n\n\ny\n \n(number)\n: Location on the other axis.\n\n\n\n\nExample\n\n\nvar\n \ntengen\n \n=\n \nnew\n \nCoordinate\n(\n9\n,\n \n9\n);\n\n\n\ntengen\n.\ntoString\n();\n\n\n// => Coordinate { \"x\": 9, \"y\": 9 }\n\n\n\ntengen\n.\nx\n;\n\n\n// => 9\n\n\n\n\n\n\nBoard\n\n\n\n\nnew\n \ngodash\n.\nBoard\n(\ndimensions\n \n=\n \n19\n,\n \n...\nmoves\n)\n\n\n\n\n\n\nClass representing a Go board.  Inherits from \nImmutable.Record\n.\n\n\nArguments\n\n\n\n\ndimensions\n \n(number)\n: Size of the board, defaulted to 19x19.\n\n\n...moves\n \n(Coordinate, string)\n: Moves to be placed on the board.  They\n  should be provided in pairs of arguments - Coordinate and color.\n\n\n\n\nProperties\n\n\n\n\ndimensions\n \n(number)\n: Size of the board.\n\n\nmoves\n \n(Immutable.Map)\n: Moves on this board, keyed by\n  \nCoordinate\n with either \nBLACK\n or \nWHITE\n as\n  the value.\n\n\n\n\nExample\n\n\nvar\n \nboard\n \n=\n \nnew\n \nBoard\n();\n\n\n\nboard\n.\ntoString\n();\n\n\n// => Board { \"dimensions\": 19, \"moves\": Map {} }\n\n\n\n\n\n\nvar\n \nsmallBoard\n \n=\n \nnew\n \nBoard\n(\n5\n,\n \nnew\n \nCoordinate\n(\n2\n,\n \n2\n),\n \nBLACK\n);\n\n\n\nsmallBoard\n.\ntoString\n();\n\n\n// => Board { \"dimensions\": 5, \"moves\": Map { {\"x\":2,\"y\":2}: \"black\" } }\n\n\n\n\n\n\naddMove\n\n\n\n\ngodash\n.\naddMove\n(\nboard\n,\n \ncoordinate\n,\n \ncolor\n)\n\n\n\n\n\n\nFunction to add a move onto a board while respecting the rules.  Since no\nsequence information is available, this function does not respect\n\nko\n.  Use \nfollowupKo()\n if you want to do\n\nko\n-related things.\n\n\nArguments\n\n\n\n\nboard\n \n(Board)\n: Board from which to add the move.\n\n\ncoordinate\n \n(Coordinate)\n: Location to add the move.\n\n\ncolor\n \n(string)\n: Color of the move - \nBLACK\n or\n  \nWHITE\n.\n\n\n\n\nReturns\n\n\n(Board)\n: New board with the move added.\n\n\nExample\n\n\nvar\n \natari\n \n=\n \nnew\n \nBoard\n(\n3\n,\n\n    \nnew\n \nCoordinate\n(\n1\n,\n \n0\n),\n \nBLACK\n,\n\n    \nnew\n \nCoordinate\n(\n0\n,\n \n1\n),\n \nBLACK\n,\n\n    \nnew\n \nCoordinate\n(\n1\n,\n \n2\n),\n \nBLACK\n,\n\n    \nnew\n \nCoordinate\n(\n1\n,\n \n1\n),\n \nWHITE\n\n\n);\n\n\n\ntoAsciiBoard\n(\natari\n);\n\n\n// => +O+\n\n\n//    OXO\n\n\n//    +++\n\n\n\nvar\n \nkilled\n \n=\n \naddMove\n(\n\n    \natari\n,\n\n    \nnew\n \nCoordinate\n(\n2\n,\n \n1\n),\n\n    \nBLACK\n\n\n);\n\n\n\ntoAsciiBoard\n(\nkilled\n);\n\n\n// => +O+\n\n\n//    O+O\n\n\n//    +O+\n\n\n\n\n\n\nconstructBoard\n\n\n\n\ngodash\n.\nconstructBoard\n(\ncoordinates\n,\n \nboard\n \n=\n \nnull\n,\n \nstartColor\n \n=\n \ngodash\n.\nBLACK\n)\n\n\n\n\n\n\nConstructs a board for an array of coordinates.  This function iteratively\ncalls \naddMove\n while alternating colors.\n\n\nArguments\n\n\n\n\ncoordinates\n \n(Array)\n: Members of this array should be of type\n  \nCoordinate\n.\n\n\nboard\n \n(Board)\n: Optional starting board.  If omitted, a\n  default \nBoard\n is created - 19x19 and empty.\n\n\nstartColor\n \n(string)\n: Optional starting color, defaulted to \nBLACK\n.\n\n\n\n\nReturns\n\n\n(Board)\n: New board constructed from the coordinates.\n\n\nExample\n\n\nvar\n \ntigersMouth\n \n=\n \nnew\n \nBoard\n(\n3\n,\n\n    \nnew\n \nCoordinate\n(\n1\n,\n \n0\n),\n \nBLACK\n,\n\n    \nnew\n \nCoordinate\n(\n0\n,\n \n1\n),\n \nBLACK\n,\n\n    \nnew\n \nCoordinate\n(\n1\n,\n \n2\n),\n \nBLACK\n\n\n);\n\n\n\ntoAsciiBoard\n(\ntigersMouth\n);\n\n\n// => +O+\n\n\n//    O+O\n\n\n//    +++\n\n\n\nvar\n \nselfAtari\n \n=\n \nnew\n \nCoordinate\n(\n1\n,\n \n1\n);\n\n\nvar\n \nkillingMove\n \n=\n \nnew\n \nCoordinate\n(\n2\n,\n \n1\n);\n\n\n\nvar\n \nponnuki\n \n=\n \nconstructBoard\n(\n\n    \n[\nselfAtari\n,\n \nkillingMove\n],\n\n    \ntigersMouth\n,\n\n    \nWHITE\n\n\n);\n\n\n\ntoAsciiBoard\n(\nponnuki\n);\n\n\n// => +O+\n\n\n//    O+O\n\n\n//    +O+\n\n\n\n\n\n\ndifference\n\n\n\n\ngodash\n.\ndifference\n(\nboard1\n,\n \nboard2\n)\n\n\n\n\n\n\nFinds the moves on the first board that are not on the second board.\n\n\nArguments\n\n\n\n\nboard1\n \n(Board)\n: First board.\n\n\nboard2\n \n(Board)\n: Board with moves to subtract from first board.\n\n\n\n\nReturns\n\n\n(Immutable.Set)\n: Set containing \nImmutable.List\n of\n\nCoordinate\n and color (\nstring\n).\n\n\nExample\n\n\nvar\n \natari\n \n=\n \nnew\n \nBoard\n(\n3\n,\n\n    \nnew\n \nCoordinate\n(\n1\n,\n \n0\n),\n \nBLACK\n,\n\n    \nnew\n \nCoordinate\n(\n0\n,\n \n1\n),\n \nBLACK\n,\n\n    \nnew\n \nCoordinate\n(\n1\n,\n \n2\n),\n \nBLACK\n,\n\n    \nnew\n \nCoordinate\n(\n1\n,\n \n1\n),\n \nWHITE\n,\n\n\n);\n\n\n\ntoAsciiBoard\n(\natari\n);\n\n\n// => +O+\n\n\n//    OXO\n\n\n//    +++\n\n\n\nvar\n \ncaptured\n \n=\n \ndifference\n(\natari\n,\n \naddMove\n(\natari\n,\n \nnew\n \nCoordinate\n(\n2\n,\n \n1\n),\n \nBLACK\n));\n\n\n\ncaptured\n.\ntoString\n();\n\n\n// 'Set { List [ Coordinate { \"x\": 1, \"y\": 1 }, \"white\" ] }'\n\n\n\n\n\n\nfollowupKo\n\n\n\n\ngodash\n.\nfollowupKo\n(\nboard\n,\n \ncoordinate\n,\n \ncolor\n)\n\n\n\n\n\n\nDetermines move that would be illegal under the \nko rule\n.\n\n\nArguments\n\n\n\n\nboard\n \n(Board)\n: Starting board.\n\n\ncoordinate\n \n(Coordinate)\n: Intended placement of stone.\n\n\ncolor\n \n(string)\n: Stone color - \nBLACK\n or \nWHITE\n.\n\n\n\n\nReturns\n\n\n(Coordinate)\n: Position of illegal followup or \nnull\n if none\nexists.\n\n\nExample\n\n\nconst\n \nkoPosition\n \n=\n \nnew\n \nBoard\n(\n4\n,\n\n    \nnew\n \nCoordinate\n(\n1\n,\n \n0\n),\n \nBLACK\n,\n\n    \nnew\n \nCoordinate\n(\n0\n,\n \n1\n),\n \nBLACK\n,\n\n    \nnew\n \nCoordinate\n(\n1\n,\n \n2\n),\n \nBLACK\n,\n\n    \nnew\n \nCoordinate\n(\n1\n,\n \n1\n),\n \nWHITE\n,\n\n    \nnew\n \nCoordinate\n(\n2\n,\n \n0\n),\n \nWHITE\n,\n\n    \nnew\n \nCoordinate\n(\n2\n,\n \n2\n),\n \nWHITE\n,\n\n    \nnew\n \nCoordinate\n(\n3\n,\n \n1\n),\n \nWHITE\n,\n\n\n);\n\n\n\ntoAsciiBoard\n(\nkoPosition\n);\n\n\n// => +O++\n\n\n//    OXO+\n\n\n//    X+X+\n\n\n//    +X++\n\n\n\nconst\n \nkoStart\n \n=\n \nnew\n \nCoordinate\n(\n2\n,\n \n1\n);\n\n\n\nfollowupKo\n(\nkoPosition\n,\n \nkoStart\n,\n \nBLACK\n).\ntoString\n();\n\n\n// => 'Coordinate { \"x\": 1, \"y\": 1 }'\n\n\n\n\n\n\ngroup\n\n\n\n\ngodash\n.\ngroup\n(\nboard\n,\n \ncoordinate\n)\n\n\n\n\n\n\nFinds the set of coordinates which identifies the fully connected group for the\ngiven location.\n\n\nArguments\n\n\n\n\nboard\n \n(Board)\n: Board to inspect.\n\n\ncoordinate\n \n(Coordinate)\n: Location to inspect.\n\n\n\n\nReturns\n\n\n(Immutable.Set)\n: Set containing \nCoordinate\n\nmembers for the group.\n\n\nExample\n\n\nvar\n \nboard\n \n=\n \nnew\n \nBoard\n(\n3\n,\n\n    \nnew\n \nCoordinate\n(\n1\n,\n \n0\n),\n \nWHITE\n,\n\n    \nnew\n \nCoordinate\n(\n0\n,\n \n2\n),\n \nWHITE\n,\n\n    \nnew\n \nCoordinate\n(\n1\n,\n \n2\n),\n \nBLACK\n,\n\n    \nnew\n \nCoordinate\n(\n2\n,\n \n2\n),\n \nBLACK\n,\n\n    \nnew\n \nCoordinate\n(\n2\n,\n \n1\n),\n \nBLACK\n\n\n);\n\n\n\ntoAsciiBoard\n(\nboard\n);\n\n\n// => ++X\n\n\n//    X+O\n\n\n//    +OO\n\n\n\ngroup\n(\nboard\n,\n \nnew\n \nCoordinate\n(\n2\n,\n \n1\n)).\ntoString\n();\n\n\n// => Set {\n\n\n//      Coordinate { \"x\": 2, \"y\": 1 },\n\n\n//      Coordinate { \"x\": 2, \"y\": 2 },\n\n\n//      Coordinate { \"x\": 1, \"y\": 2 }\n\n\n//    }\n\n\n\n\n\n\nhandicapBoard\n\n\n\n\ngodash\n.\nhandicapBoard\n(\nsize\n,\n \nhandicap\n)\n\n\n\n\n\n\nCreates a new \nBoard\n with the correct number of handicap stones\nplaced.  Only standard board sizes (9, 13, 19) are allowed.\n\n\nArguments\n\n\n\n\nsize\n \n(number)\n: Size of the board, must be 9, 13, or 19.\n\n\nhandicap\n \n(number)\n: Number of handicaps, must be 0-9.\n\n\n\n\nReturns\n\n\n(Board)\n: New board with correct handicaps placed.\n\n\nExample\n\n\nvar\n \nboard\n \n=\n \nhandicapBoard\n(\n9\n,\n \n4\n);\n\n\n\ntoAsciiBoard\n(\nboard\n);\n\n\n// => +++++++++\n\n\n//    +++++++++\n\n\n//    ++O+++O++\n\n\n//    +++++++++\n\n\n//    +++++++++\n\n\n//    +++++++++\n\n\n//    ++O+++O++\n\n\n//    +++++++++\n\n\n//    +++++++++\n\n\n\n\n\n\nisLegalMove\n\n\n\n\ngodash\n.\nisLegalMove\n(\nboard\n,\n \ncoordinate\n,\n \ncolor\n)\n\n\n\n\n\n\nDetermine whether the coordinate-color combination provided is a legal move for\nthe board.  \nKo\n is not considered.  Use \nfollowupKo()\n\nif you want to do \nko\n-related things.\n\n\nArguments\n\n\n\n\nboard\n \n(Board)\n: Board to inspect.\n\n\ncoordinate\n \n(Coordinate)\n: Location to check.\n\n\ncolor\n \n(string)\n: Color to check - \nBLACK\n or \nWHITE\n.\n\n\n\n\nReturns\n\n\n(boolean)\n: Whether the move is legal.\n\n\nExample\n\n\nvar\n \nponnuki\n \n=\n \nnew\n \nBoard\n(\n3\n,\n\n    \nnew\n \nCoordinate\n(\n1\n,\n \n0\n),\n \nBLACK\n,\n\n    \nnew\n \nCoordinate\n(\n0\n,\n \n1\n),\n \nBLACK\n,\n\n    \nnew\n \nCoordinate\n(\n1\n,\n \n2\n),\n \nBLACK\n,\n\n    \nnew\n \nCoordinate\n(\n2\n,\n \n1\n),\n \nBLACK\n\n\n);\n\n\n\ntoAsciiBoard\n(\nponnuki\n);\n\n\n// => +O+\n\n\n//    O+O\n\n\n//    +O+\n\n\n\nisLegalMove\n(\nponnuki\n,\n \nnew\n \nCoordinate\n(\n1\n,\n \n1\n),\n \nBLACK\n)\n\n\n// => true\n\n\n\nisLegalMove\n(\nponnuki\n,\n \nnew\n \nCoordinate\n(\n1\n,\n \n1\n),\n \nWHITE\n)\n\n\n// => false\n\n\n\n\n\n\nliberties\n\n\n\n\ngodash\n.\nliberties\n(\nboard\n,\n \ncoordinate\n)\n\n\n\n\n\n\nFinds the set of all liberties for the given coordinate.  If the coordinate is\npart of a group, the set of liberties are the liberties for that group.\n\n\nArguments\n\n\n\n\nboard\n \n(Board)\n: Board to inspect.\n\n\ncoordinate\n \n(Coordinate)\n: Coordinate to inspect.\n\n\n\n\nReturns\n\n\n(Immutable.Set)\n: Set containing \nCoordinate\n\nmembers for the liberties of the passed coordinate.\n\n\nExample\n\n\nvar\n \nboard\n \n=\n \nnew\n \nBoard\n(\n3\n,\n \nnew\n \nCoordinate\n(\n1\n,\n \n1\n),\n \nBLACK\n);\n\n\nvar\n \ncollectedLiberties\n \n=\n \nliberties\n(\nboard\n,\n \nnew\n \nCoordinate\n(\n1\n,\n \n1\n));\n\n\n\nImmutable\n.\nSet\n.\nof\n(\n\n    \nnew\n \nCoordinate\n(\n1\n,\n \n0\n),\n\n    \nnew\n \nCoordinate\n(\n0\n,\n \n1\n),\n\n    \nnew\n \nCoordinate\n(\n1\n,\n \n2\n),\n\n    \nnew\n \nCoordinate\n(\n2\n,\n \n1\n)\n\n\n).\nequals\n(\ncollectedLiberties\n);\n\n\n// => true\n\n\n\n\n\n\nlibertyCount\n\n\n\n\ngodash\n.\nlibertyCount\n(\nboard\n,\n \ncoordinate\n)\n\n\n\n\n\n\nCounts the liberties for the given coordinate.  If the coordinate is\npart of a group, liberties for the entire group is counted.\n\n\nArguments\n\n\n\n\nboard\n \n(Board)\n: Board to inspect.\n\n\ncoordinate\n \n(Coordinate)\n: Coordinate to inspect.\n\n\n\n\nReturns\n\n\n(number)\n: Count of liberties for the passed coordinate.\n\n\nExample\n\n\nvar\n \nboard\n \n=\n \nnew\n \nBoard\n(\n3\n,\n \nnew\n \nCoordinate\n(\n1\n,\n \n1\n),\n \nBLACK\n);\n\n\n\nlibertyCount\n(\nboard\n,\n \nnew\n \nCoordinate\n(\n1\n,\n \n1\n))\n \n===\n \n4\n;\n\n\n// => true\n\n\n\n\n\n\noppositeColor\n\n\n\n\ngodash\n.\noppositeColor\n(\ncolor\n)\n\n\n\n\n\n\nToggles the passed color.\n\n\nArguments\n\n\n\n\ncolor\n \n(string)\n: \nBLACK\n or \nWHITE\n.\n\n\n\n\nReturns\n\n\n(string)\n: Color opposite of the one provided.\n\n\nExample\n\n\noppositeColor\n(\nBLACK\n)\n \n===\n \nWHITE\n\n\n// => true\n\n\n\noppositeColor\n(\nWHITE\n)\n \n===\n \nBLACK\n\n\n// => true\n\n\n\n\n\n\nplaceStone\n\n\n\n\ngodash\n.\nplaceStone\n(\nboard\n,\n \ncoordinate\n,\n \ncolor\n,\n \nforce\n \n=\n \nfalse\n)\n\n\n\n\n\n\nPlaces a stone on the board, ignoring the rules of Go.\n\n\nArguments\n\n\n\n\nboard\n \n(Board)\n: Board to add stone.\n\n\ncoordinate\n \n(Coordinate)\n: Location to add stone.\n\n\ncolor\n \n(string)\n: Stone color - \nBLACK\n or \nWHITE\n.\n\n\nforce\n \n(boolean)\n: Optionally allow placement over existing stones.\n\n\n\n\nReturns\n\n\n(Board)\n: New board with the stone placed.\n\n\nExample\n\n\nvar\n \nponnuki\n \n=\n \nnew\n \nBoard\n(\n3\n,\n\n    \nnew\n \nCoordinate\n(\n1\n,\n \n0\n),\n \nBLACK\n,\n\n    \nnew\n \nCoordinate\n(\n0\n,\n \n1\n),\n \nBLACK\n,\n\n    \nnew\n \nCoordinate\n(\n1\n,\n \n2\n),\n \nBLACK\n,\n\n    \nnew\n \nCoordinate\n(\n2\n,\n \n1\n),\n \nBLACK\n\n\n);\n\n\n\ntoAsciiBoard\n(\nponnuki\n);\n\n\n// => +O+\n\n\n//    O+O\n\n\n//    +O+\n\n\n\ntoAsciiBoard\n(\n\n    \nplaceStone\n(\nponnuki\n,\n \nnew\n \nCoordinate\n(\n1\n,\n \n1\n),\n \nWHITE\n)\n\n\n);\n\n\n// => +O+\n\n\n//    OXO\n\n\n//    +O+\n\n\n\n\n\n\nplaceStones\n\n\n\n\ngodash\n.\nplaceStones\n(\nboard\n,\n \ncoordinates\n,\n \ncolor\n,\n \nforce\n \n=\n \nfalse\n)\n\n\n\n\n\n\nPlaces a set of stones onto the board, ignoring the rules of Go.\n\n\nArguments\n\n\n\n\nboard\n \n(Board)\n: Board to add stone.\n\n\ncoordinate\n \n(Array)\n: Stones to place.\n\n\ncolor\n \n(string)\n: Stone color - \nBLACK\n or \nWHITE\n.\n\n\nforce\n \n(boolean)\n: Optionally allow placement over existing stones.\n\n\n\n\nReturns\n\n\n(Board)\n: New board with the stones placed.\n\n\nExample\n\n\nvar\n \nboard\n \n=\n \nnew\n \nBoard\n(\n3\n,\n \nnew\n \nCoordinate\n(\n1\n,\n \n1\n),\n \nWHITE\n);\n\n\n\ntoAsciiBoard\n(\nboard\n);\n\n\n// => +++\n\n\n//    +X+\n\n\n//    +++\n\n\n\ntoAsciiBoard\n(\n\n    \nplaceStones\n(\nboard\n,\n \n[\n\n        \nnew\n \nCoordinate\n(\n1\n,\n \n0\n),\n\n        \nnew\n \nCoordinate\n(\n0\n,\n \n1\n),\n\n        \nnew\n \nCoordinate\n(\n1\n,\n \n2\n),\n\n        \nnew\n \nCoordinate\n(\n2\n,\n \n1\n)\n\n    \n],\n \nBLACK\n)\n\n\n);\n\n\n// => +O+\n\n\n//    OXO\n\n\n//    +O+\n\n\n\n\n\n\nremoveStone\n\n\n\n\ngodash\n.\nremoveStone\n(\nboard\n,\n \ncoordinate\n)\n\n\n\n\n\n\nMake a given coordinate empty on the board.\n\n\nArguments\n\n\n\n\nboard\n \n(Board)\n: Board from which to remove the stone.\n\n\ncoordinate\n \n(Coordinate)\n: Location of the stone.\n\n\n\n\nReturns\n\n\n(Board)\n: New board with the stone removed.\n\n\nExample\n\n\nvar\n \nboard\n \n=\n \nnew\n \nBoard\n(\n3\n,\n \nnew\n \nCoordinate\n(\n1\n,\n \n1\n),\n \nWHITE\n);\n\n\n\ntoAsciiBoard\n(\nboard\n);\n\n\n// => +++\n\n\n//    +X+\n\n\n//    +++\n\n\n\ntoAsciiBoard\n(\n\n    \nremoveStone\n(\nboard\n,\n \nnew\n \nCoordinate\n(\n1\n,\n \n1\n))\n\n\n);\n\n\n// => +++\n\n\n//    +++\n\n\n//    +++\n\n\n\n\n\n\nremoveStones\n\n\n\n\ngodash\n.\nremoveStones\n(\nboard\n,\n \ncoordinates\n)\n\n\n\n\n\n\nMakes several coordinates empty on the board.\n\n\nArguments\n\n\n\n\nboard\n \n(Board)\n: Board from which to remove the stones.\n\n\ncoordinate\n \n(Array)\n: Location of the stones.\n\n\n\n\nReturns\n\n\n(Board)\n: New board with the stones removed.\n\n\nExample\n\n\nvar\n \nboard\n \n=\n \nnew\n \nBoard\n(\n3\n,\n\n    \nnew\n \nCoordinate\n(\n1\n,\n \n0\n),\n \nWHITE\n,\n\n    \nnew\n \nCoordinate\n(\n1\n,\n \n1\n),\n \nWHITE\n,\n\n    \nnew\n \nCoordinate\n(\n1\n,\n \n2\n),\n \nBLACK\n\n\n);\n\n\n\ntoAsciiBoard\n(\nboard\n);\n\n\n// => +++\n\n\n//    XXO\n\n\n//    +++\n\n\n\ntoAsciiBoard\n(\n\n    \nremoveStones\n(\nboard\n,\n \n[\n\n        \nnew\n \nCoordinate\n(\n1\n,\n \n1\n),\n\n        \nnew\n \nCoordinate\n(\n1\n,\n \n2\n)\n\n    \n])\n\n\n);\n\n\n// => +++\n\n\n//    X++\n\n\n//    +++\n\n\n\n\n\n\ntoAsciiBoard\n\n\n\n\ngodash\n.\ntoAsciiBoard\n(\nboard\n)\n\n\n\n\n\n\nConstructs an ASCII representation of the board.\n\n\nArguments\n\n\n\n\nboard\n \n(Board)\n: Board from which to add the move.\n\n\n\n\nReturns\n\n\n(string)\n: ASCII representation of the board.\n\n\nExample\n\n\nvar\n \nboard\n \n=\n \nnew\n \nBoard\n(\n3\n,\n\n    \nnew\n \nCoordinate\n(\n1\n,\n \n0\n),\n \nBLACK\n,\n\n    \nnew\n \nCoordinate\n(\n0\n,\n \n1\n),\n \nBLACK\n,\n\n    \nnew\n \nCoordinate\n(\n1\n,\n \n2\n),\n \nBLACK\n,\n\n    \nnew\n \nCoordinate\n(\n1\n,\n \n1\n),\n \nWHITE\n\n\n);\n\n\n\ntoAsciiBoard\n(\nboard\n);\n\n\n// => +O+\n\n\n//    OXO\n\n\n//    +++\n\n\n\n\n\n\nBLACK\n\n\n\n\ngodash\n.\nBLACK\n \n=\n \n'black'\n\n\n\n\n\n\nConstant representing the stone color black.\n\n\nWHITE\n\n\n\n\ngodash\n.\nWHITE\n \n=\n \n'white'\n\n\n\n\n\n\nConstant representing the stone color white.\n\n\nEMPTY\n\n\n\n\ngodash\n.\nEMPTY\n \n=\n \nnull\n\n\n\n\n\n\nConstant representing an empty space.\n\n\nTENGEN_9\n\n\n\n\ngodash\n.\nTENGEN_9\n \n=\n \nnew\n \nCoordinate\n(\n4\n,\n \n4\n);\n\n\n\n\n\n\nConstant representing tengen on a 9x9 board.\n\n\nTENGEN_13\n\n\n\n\ngodash\n.\nTENGEN_13\n \n=\n \nnew\n \nCoordinate\n(\n6\n,\n \n6\n);\n\n\n\n\n\n\nConstant representing tengen on a 13x13 board.\n\n\nTENGEN_19\n\n\n\n\ngodash\n.\nTENGEN_19\n \n=\n \nnew\n \nCoordinate\n(\n9\n,\n \n9\n);\n\n\n\n\n\n\nConstant representing tengen on a 19x19 board.\n\n\nSGF\n\n\nUtilities to support \nSGF\n ingestion.\n\n\ncoordinateToSgfPoint\n\n\n\n\ngodash\n.\ncoordinateToSgfPoint\n(\ncoordinate\n)\n\n\n\n\n\n\nConverts a \nCoordinate\n to an \nSGF Point\n in the form\nof a Javascript \nString\n.\n\n\nArguments\n\n\n\n\ncoordinate\n \n(Coordinate)\n: godash \nCoordinate\n\n\n\n\nReturns\n\n\n(string)\n: 2-character string representing an \nSGF Point\n\n\nExample\n\n\ncoordinateToSgfPoint\n(\nnew\n \nCoordinate\n(\n0\n,\n \n0\n))\n\n\n// => \"aa\"\n\n\n\n\n\n\nsgfPointToCoordinate\n\n\n\n\ngodash\n.\nsgfPointToCoordinate\n(\nsgfPoint\n)\n\n\n\n\n\n\nConverts an \nSGF Point\n to a \nCoordinate\n.\n\n\nArguments\n\n\n\n\nsgfPoint\n \n(string)\n: 2-character string representing an \nSGF\n  Point\n.\n\n\n\n\nReturns\n\n\n(Coordinate)\n: Coordinate for the passed string.\n\n\nExample\n\n\nsgfPointToCoordinate\n(\n'hi'\n).\ntoString\n();\n\n\n// => Coordinate { \"x\": 7, \"y\": 8 }\n\n\n\n\n\n\nsgfToJS\n\n\n\n\ngodash\n.\nsgfToJS\n(\nsgf\n)\n\n\n\n\n\n\nConverts a raw \nSGF\n string into a plain Javascript array.  Note that\nunlike \nBoard\n, the results of this function is a mutable object.\n\n\nArguments\n\n\n\n\nsgf\n \n(string)\n: Raw \nSGF\n string to be parsed.\n\n\n\n\nReturns\n\n\n(Array)\n: Plain Javascript array that breaks down SGF variations and\nturns moves into objects.\n\n\nExample\n\n\nvar\n \nrawSgf\n \n=\n \n`(\n\n\n    ;FF[4]GM[1]SZ[19];B[aa];W[bb]\n\n\n        (;B[cc];W[dd];B[ad];W[bd])\n\n\n        (;B[hh];W[hg]C[what a move!])\n\n\n        (;B[gg];W[gh];B[hh]\n\n\n            (;W[hg];B[kk])\n\n\n            (;W[kl])\n\n\n        )\n\n\n)`\n;\n\n\n\nsgfToJS\n(\nrawSgf\n);\n\n\n// => [\n\n\n//        {FF: '4', GM: '1', SZ: '19'}, {B: 'aa'}, {W: 'bb'},\n\n\n//        [\n\n\n//            [{B: 'cc'}, {W: 'dd'}, {B: 'ad'}, {W: 'bd'}],\n\n\n//            [{B: 'hh'}, {W: 'hg', C: 'what a move!'}],\n\n\n//            [\n\n\n//                {B: 'gg'}, {W: 'gh'}, {B: 'hh'},\n\n\n//                [\n\n\n//                    [{W: 'hg'}, {B: 'kk'}],\n\n\n//                    [{W: 'kl'}]\n\n\n//                ]\n\n\n//            ]\n\n\n//        ]\n\n\n//    ];",
            "title": "Documentation"
        },
        {
            "location": "/documentation/#board",
            "text": "Utilities surrounding the board centering around an immutable  Board \nobject.",
            "title": "Board"
        },
        {
            "location": "/documentation/#coordinate",
            "text": "new   godash . Coordinate ( x ,   y )   Class representing a single location on a Go board.  Inherits from Immutable.Record .",
            "title": "Coordinate"
        },
        {
            "location": "/documentation/#arguments",
            "text": "x   (number) : Location on one axis.  y   (number) : Location on the other axis.",
            "title": "Arguments"
        },
        {
            "location": "/documentation/#properties",
            "text": "x   (number) : Location on one axis.  y   (number) : Location on the other axis.",
            "title": "Properties"
        },
        {
            "location": "/documentation/#example",
            "text": "var   tengen   =   new   Coordinate ( 9 ,   9 );  tengen . toString ();  // => Coordinate { \"x\": 9, \"y\": 9 }  tengen . x ;  // => 9",
            "title": "Example"
        },
        {
            "location": "/documentation/#board_1",
            "text": "new   godash . Board ( dimensions   =   19 ,   ... moves )   Class representing a Go board.  Inherits from  Immutable.Record .",
            "title": "Board"
        },
        {
            "location": "/documentation/#arguments_1",
            "text": "dimensions   (number) : Size of the board, defaulted to 19x19.  ...moves   (Coordinate, string) : Moves to be placed on the board.  They\n  should be provided in pairs of arguments - Coordinate and color.",
            "title": "Arguments"
        },
        {
            "location": "/documentation/#properties_1",
            "text": "dimensions   (number) : Size of the board.  moves   (Immutable.Map) : Moves on this board, keyed by\n   Coordinate  with either  BLACK  or  WHITE  as\n  the value.",
            "title": "Properties"
        },
        {
            "location": "/documentation/#example_1",
            "text": "var   board   =   new   Board ();  board . toString ();  // => Board { \"dimensions\": 19, \"moves\": Map {} }   var   smallBoard   =   new   Board ( 5 ,   new   Coordinate ( 2 ,   2 ),   BLACK );  smallBoard . toString ();  // => Board { \"dimensions\": 5, \"moves\": Map { {\"x\":2,\"y\":2}: \"black\" } }",
            "title": "Example"
        },
        {
            "location": "/documentation/#addmove",
            "text": "godash . addMove ( board ,   coordinate ,   color )   Function to add a move onto a board while respecting the rules.  Since no\nsequence information is available, this function does not respect ko .  Use  followupKo()  if you want to do ko -related things.",
            "title": "addMove"
        },
        {
            "location": "/documentation/#arguments_2",
            "text": "board   (Board) : Board from which to add the move.  coordinate   (Coordinate) : Location to add the move.  color   (string) : Color of the move -  BLACK  or\n   WHITE .",
            "title": "Arguments"
        },
        {
            "location": "/documentation/#returns",
            "text": "(Board) : New board with the move added.",
            "title": "Returns"
        },
        {
            "location": "/documentation/#example_2",
            "text": "var   atari   =   new   Board ( 3 , \n     new   Coordinate ( 1 ,   0 ),   BLACK , \n     new   Coordinate ( 0 ,   1 ),   BLACK , \n     new   Coordinate ( 1 ,   2 ),   BLACK , \n     new   Coordinate ( 1 ,   1 ),   WHITE  );  toAsciiBoard ( atari );  // => +O+  //    OXO  //    +++  var   killed   =   addMove ( \n     atari , \n     new   Coordinate ( 2 ,   1 ), \n     BLACK  );  toAsciiBoard ( killed );  // => +O+  //    O+O  //    +O+",
            "title": "Example"
        },
        {
            "location": "/documentation/#constructboard",
            "text": "godash . constructBoard ( coordinates ,   board   =   null ,   startColor   =   godash . BLACK )   Constructs a board for an array of coordinates.  This function iteratively\ncalls  addMove  while alternating colors.",
            "title": "constructBoard"
        },
        {
            "location": "/documentation/#arguments_3",
            "text": "coordinates   (Array) : Members of this array should be of type\n   Coordinate .  board   (Board) : Optional starting board.  If omitted, a\n  default  Board  is created - 19x19 and empty.  startColor   (string) : Optional starting color, defaulted to  BLACK .",
            "title": "Arguments"
        },
        {
            "location": "/documentation/#returns_1",
            "text": "(Board) : New board constructed from the coordinates.",
            "title": "Returns"
        },
        {
            "location": "/documentation/#example_3",
            "text": "var   tigersMouth   =   new   Board ( 3 , \n     new   Coordinate ( 1 ,   0 ),   BLACK , \n     new   Coordinate ( 0 ,   1 ),   BLACK , \n     new   Coordinate ( 1 ,   2 ),   BLACK  );  toAsciiBoard ( tigersMouth );  // => +O+  //    O+O  //    +++  var   selfAtari   =   new   Coordinate ( 1 ,   1 );  var   killingMove   =   new   Coordinate ( 2 ,   1 );  var   ponnuki   =   constructBoard ( \n     [ selfAtari ,   killingMove ], \n     tigersMouth , \n     WHITE  );  toAsciiBoard ( ponnuki );  // => +O+  //    O+O  //    +O+",
            "title": "Example"
        },
        {
            "location": "/documentation/#difference",
            "text": "godash . difference ( board1 ,   board2 )   Finds the moves on the first board that are not on the second board.",
            "title": "difference"
        },
        {
            "location": "/documentation/#arguments_4",
            "text": "board1   (Board) : First board.  board2   (Board) : Board with moves to subtract from first board.",
            "title": "Arguments"
        },
        {
            "location": "/documentation/#returns_2",
            "text": "(Immutable.Set) : Set containing  Immutable.List  of Coordinate  and color ( string ).",
            "title": "Returns"
        },
        {
            "location": "/documentation/#example_4",
            "text": "var   atari   =   new   Board ( 3 , \n     new   Coordinate ( 1 ,   0 ),   BLACK , \n     new   Coordinate ( 0 ,   1 ),   BLACK , \n     new   Coordinate ( 1 ,   2 ),   BLACK , \n     new   Coordinate ( 1 ,   1 ),   WHITE ,  );  toAsciiBoard ( atari );  // => +O+  //    OXO  //    +++  var   captured   =   difference ( atari ,   addMove ( atari ,   new   Coordinate ( 2 ,   1 ),   BLACK ));  captured . toString ();  // 'Set { List [ Coordinate { \"x\": 1, \"y\": 1 }, \"white\" ] }'",
            "title": "Example"
        },
        {
            "location": "/documentation/#followupko",
            "text": "godash . followupKo ( board ,   coordinate ,   color )   Determines move that would be illegal under the  ko rule .",
            "title": "followupKo"
        },
        {
            "location": "/documentation/#arguments_5",
            "text": "board   (Board) : Starting board.  coordinate   (Coordinate) : Intended placement of stone.  color   (string) : Stone color -  BLACK  or  WHITE .",
            "title": "Arguments"
        },
        {
            "location": "/documentation/#returns_3",
            "text": "(Coordinate) : Position of illegal followup or  null  if none\nexists.",
            "title": "Returns"
        },
        {
            "location": "/documentation/#example_5",
            "text": "const   koPosition   =   new   Board ( 4 , \n     new   Coordinate ( 1 ,   0 ),   BLACK , \n     new   Coordinate ( 0 ,   1 ),   BLACK , \n     new   Coordinate ( 1 ,   2 ),   BLACK , \n     new   Coordinate ( 1 ,   1 ),   WHITE , \n     new   Coordinate ( 2 ,   0 ),   WHITE , \n     new   Coordinate ( 2 ,   2 ),   WHITE , \n     new   Coordinate ( 3 ,   1 ),   WHITE ,  );  toAsciiBoard ( koPosition );  // => +O++  //    OXO+  //    X+X+  //    +X++  const   koStart   =   new   Coordinate ( 2 ,   1 );  followupKo ( koPosition ,   koStart ,   BLACK ). toString ();  // => 'Coordinate { \"x\": 1, \"y\": 1 }'",
            "title": "Example"
        },
        {
            "location": "/documentation/#group",
            "text": "godash . group ( board ,   coordinate )   Finds the set of coordinates which identifies the fully connected group for the\ngiven location.",
            "title": "group"
        },
        {
            "location": "/documentation/#arguments_6",
            "text": "board   (Board) : Board to inspect.  coordinate   (Coordinate) : Location to inspect.",
            "title": "Arguments"
        },
        {
            "location": "/documentation/#returns_4",
            "text": "(Immutable.Set) : Set containing  Coordinate \nmembers for the group.",
            "title": "Returns"
        },
        {
            "location": "/documentation/#example_6",
            "text": "var   board   =   new   Board ( 3 , \n     new   Coordinate ( 1 ,   0 ),   WHITE , \n     new   Coordinate ( 0 ,   2 ),   WHITE , \n     new   Coordinate ( 1 ,   2 ),   BLACK , \n     new   Coordinate ( 2 ,   2 ),   BLACK , \n     new   Coordinate ( 2 ,   1 ),   BLACK  );  toAsciiBoard ( board );  // => ++X  //    X+O  //    +OO  group ( board ,   new   Coordinate ( 2 ,   1 )). toString ();  // => Set {  //      Coordinate { \"x\": 2, \"y\": 1 },  //      Coordinate { \"x\": 2, \"y\": 2 },  //      Coordinate { \"x\": 1, \"y\": 2 }  //    }",
            "title": "Example"
        },
        {
            "location": "/documentation/#handicapboard",
            "text": "godash . handicapBoard ( size ,   handicap )   Creates a new  Board  with the correct number of handicap stones\nplaced.  Only standard board sizes (9, 13, 19) are allowed.",
            "title": "handicapBoard"
        },
        {
            "location": "/documentation/#arguments_7",
            "text": "size   (number) : Size of the board, must be 9, 13, or 19.  handicap   (number) : Number of handicaps, must be 0-9.",
            "title": "Arguments"
        },
        {
            "location": "/documentation/#returns_5",
            "text": "(Board) : New board with correct handicaps placed.",
            "title": "Returns"
        },
        {
            "location": "/documentation/#example_7",
            "text": "var   board   =   handicapBoard ( 9 ,   4 );  toAsciiBoard ( board );  // => +++++++++  //    +++++++++  //    ++O+++O++  //    +++++++++  //    +++++++++  //    +++++++++  //    ++O+++O++  //    +++++++++  //    +++++++++",
            "title": "Example"
        },
        {
            "location": "/documentation/#islegalmove",
            "text": "godash . isLegalMove ( board ,   coordinate ,   color )   Determine whether the coordinate-color combination provided is a legal move for\nthe board.   Ko  is not considered.  Use  followupKo() \nif you want to do  ko -related things.",
            "title": "isLegalMove"
        },
        {
            "location": "/documentation/#arguments_8",
            "text": "board   (Board) : Board to inspect.  coordinate   (Coordinate) : Location to check.  color   (string) : Color to check -  BLACK  or  WHITE .",
            "title": "Arguments"
        },
        {
            "location": "/documentation/#returns_6",
            "text": "(boolean) : Whether the move is legal.",
            "title": "Returns"
        },
        {
            "location": "/documentation/#example_8",
            "text": "var   ponnuki   =   new   Board ( 3 , \n     new   Coordinate ( 1 ,   0 ),   BLACK , \n     new   Coordinate ( 0 ,   1 ),   BLACK , \n     new   Coordinate ( 1 ,   2 ),   BLACK , \n     new   Coordinate ( 2 ,   1 ),   BLACK  );  toAsciiBoard ( ponnuki );  // => +O+  //    O+O  //    +O+  isLegalMove ( ponnuki ,   new   Coordinate ( 1 ,   1 ),   BLACK )  // => true  isLegalMove ( ponnuki ,   new   Coordinate ( 1 ,   1 ),   WHITE )  // => false",
            "title": "Example"
        },
        {
            "location": "/documentation/#liberties",
            "text": "godash . liberties ( board ,   coordinate )   Finds the set of all liberties for the given coordinate.  If the coordinate is\npart of a group, the set of liberties are the liberties for that group.",
            "title": "liberties"
        },
        {
            "location": "/documentation/#arguments_9",
            "text": "board   (Board) : Board to inspect.  coordinate   (Coordinate) : Coordinate to inspect.",
            "title": "Arguments"
        },
        {
            "location": "/documentation/#returns_7",
            "text": "(Immutable.Set) : Set containing  Coordinate \nmembers for the liberties of the passed coordinate.",
            "title": "Returns"
        },
        {
            "location": "/documentation/#example_9",
            "text": "var   board   =   new   Board ( 3 ,   new   Coordinate ( 1 ,   1 ),   BLACK );  var   collectedLiberties   =   liberties ( board ,   new   Coordinate ( 1 ,   1 ));  Immutable . Set . of ( \n     new   Coordinate ( 1 ,   0 ), \n     new   Coordinate ( 0 ,   1 ), \n     new   Coordinate ( 1 ,   2 ), \n     new   Coordinate ( 2 ,   1 )  ). equals ( collectedLiberties );  // => true",
            "title": "Example"
        },
        {
            "location": "/documentation/#libertycount",
            "text": "godash . libertyCount ( board ,   coordinate )   Counts the liberties for the given coordinate.  If the coordinate is\npart of a group, liberties for the entire group is counted.",
            "title": "libertyCount"
        },
        {
            "location": "/documentation/#arguments_10",
            "text": "board   (Board) : Board to inspect.  coordinate   (Coordinate) : Coordinate to inspect.",
            "title": "Arguments"
        },
        {
            "location": "/documentation/#returns_8",
            "text": "(number) : Count of liberties for the passed coordinate.",
            "title": "Returns"
        },
        {
            "location": "/documentation/#example_10",
            "text": "var   board   =   new   Board ( 3 ,   new   Coordinate ( 1 ,   1 ),   BLACK );  libertyCount ( board ,   new   Coordinate ( 1 ,   1 ))   ===   4 ;  // => true",
            "title": "Example"
        },
        {
            "location": "/documentation/#oppositecolor",
            "text": "godash . oppositeColor ( color )   Toggles the passed color.",
            "title": "oppositeColor"
        },
        {
            "location": "/documentation/#arguments_11",
            "text": "color   (string) :  BLACK  or  WHITE .",
            "title": "Arguments"
        },
        {
            "location": "/documentation/#returns_9",
            "text": "(string) : Color opposite of the one provided.",
            "title": "Returns"
        },
        {
            "location": "/documentation/#example_11",
            "text": "oppositeColor ( BLACK )   ===   WHITE  // => true  oppositeColor ( WHITE )   ===   BLACK  // => true",
            "title": "Example"
        },
        {
            "location": "/documentation/#placestone",
            "text": "godash . placeStone ( board ,   coordinate ,   color ,   force   =   false )   Places a stone on the board, ignoring the rules of Go.",
            "title": "placeStone"
        },
        {
            "location": "/documentation/#arguments_12",
            "text": "board   (Board) : Board to add stone.  coordinate   (Coordinate) : Location to add stone.  color   (string) : Stone color -  BLACK  or  WHITE .  force   (boolean) : Optionally allow placement over existing stones.",
            "title": "Arguments"
        },
        {
            "location": "/documentation/#returns_10",
            "text": "(Board) : New board with the stone placed.",
            "title": "Returns"
        },
        {
            "location": "/documentation/#example_12",
            "text": "var   ponnuki   =   new   Board ( 3 , \n     new   Coordinate ( 1 ,   0 ),   BLACK , \n     new   Coordinate ( 0 ,   1 ),   BLACK , \n     new   Coordinate ( 1 ,   2 ),   BLACK , \n     new   Coordinate ( 2 ,   1 ),   BLACK  );  toAsciiBoard ( ponnuki );  // => +O+  //    O+O  //    +O+  toAsciiBoard ( \n     placeStone ( ponnuki ,   new   Coordinate ( 1 ,   1 ),   WHITE )  );  // => +O+  //    OXO  //    +O+",
            "title": "Example"
        },
        {
            "location": "/documentation/#placestones",
            "text": "godash . placeStones ( board ,   coordinates ,   color ,   force   =   false )   Places a set of stones onto the board, ignoring the rules of Go.",
            "title": "placeStones"
        },
        {
            "location": "/documentation/#arguments_13",
            "text": "board   (Board) : Board to add stone.  coordinate   (Array) : Stones to place.  color   (string) : Stone color -  BLACK  or  WHITE .  force   (boolean) : Optionally allow placement over existing stones.",
            "title": "Arguments"
        },
        {
            "location": "/documentation/#returns_11",
            "text": "(Board) : New board with the stones placed.",
            "title": "Returns"
        },
        {
            "location": "/documentation/#example_13",
            "text": "var   board   =   new   Board ( 3 ,   new   Coordinate ( 1 ,   1 ),   WHITE );  toAsciiBoard ( board );  // => +++  //    +X+  //    +++  toAsciiBoard ( \n     placeStones ( board ,   [ \n         new   Coordinate ( 1 ,   0 ), \n         new   Coordinate ( 0 ,   1 ), \n         new   Coordinate ( 1 ,   2 ), \n         new   Coordinate ( 2 ,   1 ) \n     ],   BLACK )  );  // => +O+  //    OXO  //    +O+",
            "title": "Example"
        },
        {
            "location": "/documentation/#removestone",
            "text": "godash . removeStone ( board ,   coordinate )   Make a given coordinate empty on the board.",
            "title": "removeStone"
        },
        {
            "location": "/documentation/#arguments_14",
            "text": "board   (Board) : Board from which to remove the stone.  coordinate   (Coordinate) : Location of the stone.",
            "title": "Arguments"
        },
        {
            "location": "/documentation/#returns_12",
            "text": "(Board) : New board with the stone removed.",
            "title": "Returns"
        },
        {
            "location": "/documentation/#example_14",
            "text": "var   board   =   new   Board ( 3 ,   new   Coordinate ( 1 ,   1 ),   WHITE );  toAsciiBoard ( board );  // => +++  //    +X+  //    +++  toAsciiBoard ( \n     removeStone ( board ,   new   Coordinate ( 1 ,   1 ))  );  // => +++  //    +++  //    +++",
            "title": "Example"
        },
        {
            "location": "/documentation/#removestones",
            "text": "godash . removeStones ( board ,   coordinates )   Makes several coordinates empty on the board.",
            "title": "removeStones"
        },
        {
            "location": "/documentation/#arguments_15",
            "text": "board   (Board) : Board from which to remove the stones.  coordinate   (Array) : Location of the stones.",
            "title": "Arguments"
        },
        {
            "location": "/documentation/#returns_13",
            "text": "(Board) : New board with the stones removed.",
            "title": "Returns"
        },
        {
            "location": "/documentation/#example_15",
            "text": "var   board   =   new   Board ( 3 , \n     new   Coordinate ( 1 ,   0 ),   WHITE , \n     new   Coordinate ( 1 ,   1 ),   WHITE , \n     new   Coordinate ( 1 ,   2 ),   BLACK  );  toAsciiBoard ( board );  // => +++  //    XXO  //    +++  toAsciiBoard ( \n     removeStones ( board ,   [ \n         new   Coordinate ( 1 ,   1 ), \n         new   Coordinate ( 1 ,   2 ) \n     ])  );  // => +++  //    X++  //    +++",
            "title": "Example"
        },
        {
            "location": "/documentation/#toasciiboard",
            "text": "godash . toAsciiBoard ( board )   Constructs an ASCII representation of the board.",
            "title": "toAsciiBoard"
        },
        {
            "location": "/documentation/#arguments_16",
            "text": "board   (Board) : Board from which to add the move.",
            "title": "Arguments"
        },
        {
            "location": "/documentation/#returns_14",
            "text": "(string) : ASCII representation of the board.",
            "title": "Returns"
        },
        {
            "location": "/documentation/#example_16",
            "text": "var   board   =   new   Board ( 3 , \n     new   Coordinate ( 1 ,   0 ),   BLACK , \n     new   Coordinate ( 0 ,   1 ),   BLACK , \n     new   Coordinate ( 1 ,   2 ),   BLACK , \n     new   Coordinate ( 1 ,   1 ),   WHITE  );  toAsciiBoard ( board );  // => +O+  //    OXO  //    +++",
            "title": "Example"
        },
        {
            "location": "/documentation/#black",
            "text": "godash . BLACK   =   'black'   Constant representing the stone color black.",
            "title": "BLACK"
        },
        {
            "location": "/documentation/#white",
            "text": "godash . WHITE   =   'white'   Constant representing the stone color white.",
            "title": "WHITE"
        },
        {
            "location": "/documentation/#empty",
            "text": "godash . EMPTY   =   null   Constant representing an empty space.",
            "title": "EMPTY"
        },
        {
            "location": "/documentation/#tengen_9",
            "text": "godash . TENGEN_9   =   new   Coordinate ( 4 ,   4 );   Constant representing tengen on a 9x9 board.",
            "title": "TENGEN_9"
        },
        {
            "location": "/documentation/#tengen_13",
            "text": "godash . TENGEN_13   =   new   Coordinate ( 6 ,   6 );   Constant representing tengen on a 13x13 board.",
            "title": "TENGEN_13"
        },
        {
            "location": "/documentation/#tengen_19",
            "text": "godash . TENGEN_19   =   new   Coordinate ( 9 ,   9 );   Constant representing tengen on a 19x19 board.",
            "title": "TENGEN_19"
        },
        {
            "location": "/documentation/#sgf",
            "text": "Utilities to support  SGF  ingestion.",
            "title": "SGF"
        },
        {
            "location": "/documentation/#coordinatetosgfpoint",
            "text": "godash . coordinateToSgfPoint ( coordinate )   Converts a  Coordinate  to an  SGF Point  in the form\nof a Javascript  String .",
            "title": "coordinateToSgfPoint"
        },
        {
            "location": "/documentation/#arguments_17",
            "text": "coordinate   (Coordinate) : godash  Coordinate",
            "title": "Arguments"
        },
        {
            "location": "/documentation/#returns_15",
            "text": "(string) : 2-character string representing an  SGF Point",
            "title": "Returns"
        },
        {
            "location": "/documentation/#example_17",
            "text": "coordinateToSgfPoint ( new   Coordinate ( 0 ,   0 ))  // => \"aa\"",
            "title": "Example"
        },
        {
            "location": "/documentation/#sgfpointtocoordinate",
            "text": "godash . sgfPointToCoordinate ( sgfPoint )   Converts an  SGF Point  to a  Coordinate .",
            "title": "sgfPointToCoordinate"
        },
        {
            "location": "/documentation/#arguments_18",
            "text": "sgfPoint   (string) : 2-character string representing an  SGF\n  Point .",
            "title": "Arguments"
        },
        {
            "location": "/documentation/#returns_16",
            "text": "(Coordinate) : Coordinate for the passed string.",
            "title": "Returns"
        },
        {
            "location": "/documentation/#example_18",
            "text": "sgfPointToCoordinate ( 'hi' ). toString ();  // => Coordinate { \"x\": 7, \"y\": 8 }",
            "title": "Example"
        },
        {
            "location": "/documentation/#sgftojs",
            "text": "godash . sgfToJS ( sgf )   Converts a raw  SGF  string into a plain Javascript array.  Note that\nunlike  Board , the results of this function is a mutable object.",
            "title": "sgfToJS"
        },
        {
            "location": "/documentation/#arguments_19",
            "text": "sgf   (string) : Raw  SGF  string to be parsed.",
            "title": "Arguments"
        },
        {
            "location": "/documentation/#returns_17",
            "text": "(Array) : Plain Javascript array that breaks down SGF variations and\nturns moves into objects.",
            "title": "Returns"
        },
        {
            "location": "/documentation/#example_19",
            "text": "var   rawSgf   =   `(      ;FF[4]GM[1]SZ[19];B[aa];W[bb]          (;B[cc];W[dd];B[ad];W[bd])          (;B[hh];W[hg]C[what a move!])          (;B[gg];W[gh];B[hh]              (;W[hg];B[kk])              (;W[kl])          )  )` ;  sgfToJS ( rawSgf );  // => [  //        {FF: '4', GM: '1', SZ: '19'}, {B: 'aa'}, {W: 'bb'},  //        [  //            [{B: 'cc'}, {W: 'dd'}, {B: 'ad'}, {W: 'bd'}],  //            [{B: 'hh'}, {W: 'hg', C: 'what a move!'}],  //            [  //                {B: 'gg'}, {W: 'gh'}, {B: 'hh'},  //                [  //                    [{W: 'hg'}, {B: 'kk'}],  //                    [{W: 'kl'}]  //                ]  //            ]  //        ]  //    ];",
            "title": "Example"
        }
    ]
}